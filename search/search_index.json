{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pytastic","text":"<p>No Magic. Just Python.</p> <p>Pytastic is a lightweight, dependency-free validation library that respects your standard Python type hints. It compiles <code>TypedDict</code> schemas into highly optimized Python code, making it strictly compliant and faster than many alternatives.</p>"},{"location":"#why-pytastic","title":"Why Pytastic?","text":"<ul> <li>Zero Dependencies: Pure Python standard library only.</li> <li>Fast: Uses compiled code generation to beat <code>pydantic</code>.</li> <li>Standard: Uses <code>TypedDict</code> and <code>Annotated</code> from <code>typing</code>.</li> <li>Safe: Strict validation options available.</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Benchmark results (100,000 validation iterations):</p> Library Time (s) Ops/sec Relative msgspec 0.053 1,877,872 1.00x Pytastic 0.179 557,277 3.37x Pydantic 0.200 499,381 3.76x"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pytastic\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"Typed SyntaxDynamic Syntax <pre><code>from pytastic import Pytastic\nfrom typing import TypedDict, Annotated, Literal\n\nvx = Pytastic()\n\nclass User(TypedDict):\n    username: Annotated[str, \"min_len=3\"]\n    age: Annotated[int, \"min=18\"]\n    role: Literal[\"admin\", \"user\"]\n\n# Validate directly\ndata = {\"username\": \"tersoo\", \"age\": 25, \"role\": \"admin\"}\nuser = vx.validate(User, data)\nprint(user)\n</code></pre> <pre><code>vx.register(User)\n\n# Use as a method on vx\nuser = vx.User({\"username\": \"tersoo\", \"age\": 25, \"role\": \"admin\"})\n</code></pre>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#dynamic-syntax","title":"Dynamic Syntax","text":"<p>While standard validation uses <code>vx.validate(Schema, data)</code>, Pytastic offers a more concise, \"dynamic\" syntax for rapid development.</p> <p>Once you register a schema, it becomes available as a method on the Pytastic instance.</p> <pre><code>from pytastic import Pytastic\nfrom typing import TypedDict\n\nclass User(TypedDict):\n    name: str\n\nvx = Pytastic()\nvx.register(User)\n\n# Standard\nuser = vx.validate(User, {\"name\": \"Alice\"})\n\n# Dynamic (Cleaner!)\nuser = vx.User({\"name\": \"Alice\"})\n</code></pre> <p>This is particularly useful if you are using Pytastic as a minimal dependency-injection style validator in scripts.</p>"},{"location":"advanced/#nested-validation","title":"Nested Validation","text":"<p>Pytastic handles nested <code>TypedDict</code>s automatically. You don't need to manually validate sub-objects.</p> <pre><code>class Address(TypedDict):\n    street: str\n    city: str\n    zip: Annotated[str, \"min_len=5\"]\n\nclass User(TypedDict):\n    username: str\n    # Just reference the TypedDict class!\n    address: Address\n\ndata = {\n    \"username\": \"tersoo\",\n    \"address\": {\n        \"street\": \"123 Python Way\",\n        \"city\": \"Codeville\",\n        \"zip\": \"90210\"\n    }\n}\n\n# helper will validate 'Address' recursively\nvx.validate(User, data)\n</code></pre>"},{"location":"advanced/#how-pytastic-works-code-generation","title":"How Pytastic Works (Code Generation)","text":"<p>Under the hood, Pytastic does not interpret your schema at runtime. That would be slow.</p> <p>Instead, when you call <code>register</code> (or the first time you <code>validate</code>), Pytastic: 1.  Analyzes your <code>TypedDict</code> and <code>Annotated</code> hints. 2.  Generates optimal Python source code for a validation function (e.g., <code>def validate_User(...)</code>). 3.  Compiles this functions using <code>exec()</code> into memory. 4.  Caches it for future calls.</p> <p>This \"Just-In-Time\" (JIT) compilation means Pytastic runs as fast as hand-written validation code, avoiding the overhead of traversing schema objects for every record.</p>"},{"location":"advanced/#viewing-generated-code","title":"Viewing Generated Code","text":"<p>(Internal Feature) If you are debugging, you can inspect the generated code by looking at the <code>codegen.py</code> compiler output, or by inspecting the compiled function wrapper. This is transparent to you as a user but explains why Pytastic benchmarks so effectively.</p>"},{"location":"json_schema/","title":"JSON Schema Export","text":"<p>Pytastic bridges the gap between Python types and standard JSON Schema. You can export any Pytastic-compatible <code>TypedDict</code> to a JSON Schema string, perfect for sharing with frontends (React, Vue) or other services.</p>"},{"location":"json_schema/#basic-export","title":"Basic Export","text":"<p>Use the <code>vx.schema()</code> method.</p> <pre><code>import json\nfrom pytastic import Pytastic\nfrom typing import TypedDict, Annotated\n\nclass Product(TypedDict):\n    id: Annotated[int, \"min=1\"]\n    name: Annotated[str, \"min_len=3\"]\n    tags: Annotated[List[str], \"unique\"]\n\nvx = Pytastic()\n\n# Get schema as a JSON string\nschema_json = vx.schema(Product)\nprint(schema_json)\n</code></pre>"},{"location":"json_schema/#output","title":"Output","text":"<pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"minimum\": 1.0\n    },\n    \"name\": {\n      \"type\": \"string\",\n      \"minLength\": 3\n    },\n    \"tags\": {\n      \"type\": \"array\",\n      \"uniqueItems\": true,\n      \"items\": {\n        \"type\": \"string\"\n      }\n    }\n  },\n  \"required\": [\n    \"id\",\n    \"name\",\n    \"tags\"\n  ],\n  \"additionalProperties\": true\n}\n</code></pre>"},{"location":"json_schema/#features-supported","title":"Features Supported","text":"<p>The schema generator respects all Pytastic constraints:</p> <ul> <li>Numbers: <code>minimum</code>, <code>maximum</code>, <code>multipleOf</code>.</li> <li>Strings: <code>minLength</code>, <code>maxLength</code>, <code>pattern</code>, <code>format</code>.</li> <li>Collections: <code>minItems</code>, <code>maxItems</code>, <code>uniqueItems</code>.</li> <li>Tuples: Generates <code>prefixItems</code> (JSON Schema 2020-12) for position-dependent validation.</li> <li>Unions: Generates <code>oneOf</code> or <code>anyOf</code>.</li> <li>Literals: Generates <code>enum</code> (and <code>type: null</code> for <code>None</code>).</li> </ul>"},{"location":"json_schema/#metadata-title-description-default","title":"Metadata (<code>title</code>, <code>description</code>, <code>default</code>)","text":"<p>You can add standard JSON Schema metadata using <code>Annotated</code>. Pytastic extracts these fields and injects them into the schema.</p> <pre><code>from typing import Annotated, TypedDict\nfrom pytastic import Pytastic\n\nclass Config(TypedDict):\n    api_key: Annotated[str, \"description='Your API Key'; title='API Key'\"]\n    retries: Annotated[int, \"default=5; description='Number of retries'\"]\n\nvx = Pytastic()\nschema = vx.schema(Config)\n# {\n#   \"type\": \"object\",\n#   \"properties\": {\n#     \"api_key\": { \"type\": \"string\", \"title\": \"API Key\", \"description\": \"Your API Key\" },\n#     \"retries\": { \"type\": \"integer\", \"default\": 5, \"description\": \"Number of retries\" }\n#   },\n#   ...\n# }\n</code></pre>"},{"location":"json_schema/#optional-and-required-fields","title":"Optional and Required Fields","text":"<ul> <li>Required: By default, all fields in a <code>TypedDict</code> are required.</li> <li>Optional (<code>NotRequired</code>): Use <code>typing.NotRequired</code> (or <code>total=False</code>) to make fields optional in the schema (removed from <code>required</code> list).</li> <li>Nullable (<code>Optional</code>): Use <code>typing.Optional[T]</code> to allow <code>null</code> values (<code>anyOf: [{type: T}, {type: \"null\"}]</code>).</li> </ul> <pre><code>try:\n    from typing import NotRequired # Python 3.11+\nexcept ImportError:\n    from typing_extensions import NotRequired\n\nclass User(TypedDict):\n    id: int                     # Required, integer\n    name: NotRequired[str]      # Optional property, string\n    bio: Optional[str]          # Required property, string OR null\n</code></pre>"},{"location":"json_schema/#usage-in-apis","title":"Usage in APIs","text":"<p>You can serve this schema directly from your API endpoints so clients know exactly what data format to send.</p> <pre><code># Flask example\n@app.route(\"/schema/product\")\ndef get_product_schema():\n    return vx.schema(Product), 200, {'Content-Type': 'application/json'}\n</code></pre>"},{"location":"syntax/","title":"Annotation Syntax","text":"<p>Pytastic uses <code>typing.Annotated</code> to define constraints. The syntax is a simple semi-colon separated string:</p> <pre><code>Annotated[Type, \"constraint1=value; constraint2=value; flag\"]\n</code></pre>"},{"location":"syntax/#numeric-constraints","title":"Numeric Constraints","text":"<p>Applies to <code>int</code> and <code>float</code>.</p> Constraint Aliases Description Example <code>min</code> Minimum value (inclusive) <code>\"min=0\"</code> <code>max</code> Maximum value (inclusive) <code>\"max=100\"</code> <code>exclusive_min</code> Minimum value (exclusive) <code>\"exclusive_min=0\"</code> <code>exclusive_max</code> Maximum value (exclusive) <code>\"exclusive_max=100\"</code> <code>step</code> <code>multiple_of</code> Value must be a multiple of this <code>\"step=0.5\"</code>"},{"location":"syntax/#examples","title":"Examples","text":"Age ValidationPercentageStep/Multiple <pre><code>class Person(TypedDict):\n    # Must be 18 or older\n    age: Annotated[int, \"min=18\"]\n</code></pre> <pre><code>class Stats(TypedDict):\n    # 0.0 to 1.0\n    score: Annotated[float, \"min=0; max=1\"]\n</code></pre> <pre><code>class Product(TypedDict):\n    # Must be customizable in 0.5kg increments\n    weight: Annotated[float, \"step=0.5\"]\n</code></pre>"},{"location":"syntax/#string-constraints","title":"String Constraints","text":"<p>Applies to <code>str</code>.</p> Constraint Aliases Description Example <code>min_len</code> <code>min_length</code> Minimum character length <code>\"min_len=3\"</code> <code>max_len</code> <code>max_length</code> Maximum character length <code>\"max_len=20\"</code> <code>regex</code> <code>pattern</code> Regular expression match <code>\"regex='^[a-z]+$'\"</code> <code>format</code> Pre-defined formats <code>\"format=email\"</code>"},{"location":"syntax/#supported-formats","title":"Supported Formats","text":"Format Description <code>email</code> Basic email structure check (<code>@</code>) <code>uuid</code> UUID v4 format <code>ipv4</code> IPv4 address (e.g., <code>192.168.1.1</code>) <code>date-time</code> ISO8601 date-time (e.g., <code>2024-01-15T10:30:00</code>) <code>uri</code> URI format (e.g., <code>https://example.com</code>)"},{"location":"syntax/#examples_1","title":"Examples","text":"UsernameEmailIPv4 AddressTimestamp <pre><code>class User(TypedDict):\n    # Alphanumeric, 3-20 chars\n    username: Annotated[str, \"min_len=3; max_len=20; regex='^[a-zA-Z0-9_]+$'\"]\n</code></pre> <pre><code>class Contact(TypedDict):\n    email: Annotated[str, \"format=email\"]\n</code></pre> <pre><code>class Server(TypedDict):\n    ip: Annotated[str, \"format=ipv4\"]\n</code></pre> <pre><code>class Event(TypedDict):\n    created_at: Annotated[str, \"format=date-time\"]\n</code></pre>"},{"location":"syntax/#collection-constraints","title":"Collection Constraints","text":"<p>Applies to <code>List</code>, <code>list</code>, <code>Tuple</code>, or <code>tuple</code>.</p> Constraint Aliases Description Example <code>min_items</code> Minimum list length <code>\"min_items=1\"</code> <code>max_items</code> Maximum list length <code>\"max_items=5\"</code> <code>unique</code> <code>unique_items</code> All items must be unique <code>\"unique\"</code> <code>contains</code> At least one item must match <code>\"contains='regex=^admin$'\"</code>"},{"location":"syntax/#examples_2","title":"Examples","text":"Tags ListContains Check <pre><code>class Post(TypedDict):\n    # 1 to 5 unique tags\n    tags: Annotated[List[str], \"min_items=1; max_items=5; unique\"]\n</code></pre> <pre><code>class User(TypedDict):\n    # Must have at least one 'admin' role\n    roles: Annotated[List[str], \"contains='regex=^admin$'\"]\n</code></pre>"},{"location":"syntax/#conditional-validation","title":"Conditional Validation","text":"<p>Make validation rules depend on the values of other fields using the <code>condition ? constraint</code> syntax.</p> <p>Syntax: <code>field==value ? constraint</code></p> <p>This is powerful for forms and APIs where field requirements change based on user input.</p>"},{"location":"syntax/#examples_3","title":"Examples","text":"Conditional RequiredConditional ConstraintObject-Level Conditions <pre><code>class Payment(TypedDict):\n    payment_type: Annotated[str, \"regex='^(credit|cash)$'\"]\n    # Card number is required ONLY if payment_type is 'credit'\n    card_number: Annotated[NotRequired[str], \"payment_type==credit ? required\"]\n</code></pre> <pre><code>class User(TypedDict):\n    user_type: str\n    # Business users need longer usernames\n    username: Annotated[str, \"user_type==business ? min_len=10\"]\n</code></pre> <pre><code>class Order(TypedDict):\n    # Use _ field for object-level rules\n    _: Annotated[Any, \"payment==credit ? card_number=required\"]\n    payment: str\n    card_number: NotRequired[str]\n</code></pre>"},{"location":"syntax/#logical-operators","title":"Logical Operators","text":"<p>Combine validation rules using <code>|</code> (OR) and <code>!</code> (NOT).</p>"},{"location":"syntax/#or","title":"OR (<code>|</code>)","text":"<p>Matches if either constraint passes.</p> <pre><code>class Contact(TypedDict):\n    # Field must be either an email OR a numeric ID\n    contact_info: Annotated[str, \"format=email | regex='^[0-9]+$'\"]\n</code></pre>"},{"location":"syntax/#not","title":"NOT (<code>!</code>)","text":"<p>Matches if the constraint fails.</p> <pre><code>class Password(TypedDict):\n    # Must NOT be exactly 'password'\n    secret: Annotated[str, \"!regex='^password$'; min_len=1\"]\n</code></pre>"},{"location":"syntax/#combined-example","title":"Combined Example","text":"<pre><code>class Username(TypedDict):\n    # Email OR alphanumeric, but NOT 'admin'\n    name: Annotated[str, \"format=email | regex='^[a-z0-9]+$'; !regex='^admin$'\"]\n</code></pre> <p>Note: When using regex patterns containing <code>|</code>, wrap them in single quotes to avoid conflicts with the OR operator: <code>\"regex='^(a|b)$'\"</code>.</p>"},{"location":"syntax/#tuple-constraints","title":"Tuple Constraints","text":"<p>Standard <code>Tuple</code> support works as expected for fixed-size arrays.</p> <pre><code>class Point(TypedDict):\n    # Exactly 2 floats: lat, lng\n    lat_lng: Tuple[float, float]\n\nclass UserRecord(TypedDict):\n    # Exact structure: (id, name, is_active)\n    record: Tuple[int, str, bool]\n</code></pre>"},{"location":"syntax/#object-constraints-strict-mode","title":"Object Constraints (Strict Mode)","text":"<p>Apply constraints to the <code>TypedDict</code> itself using a special <code>_</code> metadata field.</p> Constraint Aliases Description Example <code>strict</code> Disallow extra fields <code>\"strict\"</code> <code>min_props</code> <code>min_properties</code> Minimum number of present keys <code>\"min_props=2\"</code>"},{"location":"syntax/#examples_4","title":"Examples","text":"Strict User <pre><code>class User(TypedDict):\n    # Rejects input with extra keys!\n    _: Annotated[Any, \"strict\"]\n    name: str\n    age: int\n\n# Valid\nvx.validate(User, {\"name\": \"A\", \"age\": 1})\n\n# Invalid (raises ValidationError due to 'extra')\nvx.validate(User, {\"name\": \"A\", \"age\": 1, \"extra\": True})\n</code></pre>"},{"location":"syntax/#union-types","title":"Union Types","text":"<p>Pytastic supports <code>Union</code> and <code>Optional</code> (which is <code>Union[T, None]</code>).</p> <ul> <li>AnyOf (Default): Tries to match any type. Returns the first valid match.</li> <li>OneOf: Ensures data matches exactly one type.</li> </ul> <p>To specify <code>one_of</code>, enclose the Union in <code>Annotated</code>.</p> <pre><code>class Search(TypedDict):\n    # Can be a string OR a list of strings\n    query: Union[str, List[str]]\n\nclass Exclusive(TypedDict):\n    # Must be EITHER int OR float, but not both\n    value: Annotated[Union[int, float], \"one_of\"]\n</code></pre>"},{"location":"syntax/#literal-types","title":"Literal Types","text":"<p>Ensures value is one of a specific set of constants.</p> <pre><code>class Config(TypedDict):\n    # Must be exactly \"json\" or \"yaml\"\n    format: Literal[\"json\", \"yaml\"]\n\n    # Can also use numbers\n    version: Literal[1, 2, 3]\n</code></pre>"},{"location":"syntax/#json-schema-metadata","title":"JSON Schema Metadata","text":"<p>You can also use <code>Annotated</code> to provide metadata for JSON Schema export (<code>title</code>, <code>description</code>, <code>default</code>). See JSON Schema Export for details.</p>"}]}